<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®Œæ•´é˜´å½±æ¨¡æ‹Ÿå™¨ - é›†æˆç‰ˆ</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- è‡ªå®šä¹‰æ ·å¼ -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: white;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 1000;
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .control-panel {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .control-group input[type="range"] {
            margin: 10px 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            flex: 1;
            min-width: 80px;
        }

        button:hover {
            background: #2980b9;
        }

        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .toggle-button {
            background: #e74c3c;
        }

        .toggle-button.active {
            background: #27ae60;
        }

        .info-panel {
            padding: 15px;
            background: #ecf0f1;
            font-size: 12px;
            color: #34495e;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        .status.info {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status.warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
            align-items: center;
            margin: 5px 0;
        }

        .layer-controls input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }

        .time-display {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            background: #34495e;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .sun-info {
            background: #fff3cd;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            margin: 10px 0;
        }

        .coordinates {
            background: #d1ecf1;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
        }
        
        .analysis-center {
            font-size: 16px;
            text-align: center;
            line-height: 20px;
        }
        
        .radius-display {
            display: inline-block;
            min-width: 40px;
            text-align: center;
            font-weight: bold;
            color: #3498db;
        }
        
        .popup-content h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .popup-content h5 {
            margin: 10px 0 5px 0;
            color: #34495e;
            font-size: 14px;
        }
        
        .shadow-level {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            border-bottom: 1px dotted #ddd;
        }
        
        .shadow-level:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¾§è¾¹æ æ§åˆ¶é¢æ¿ -->
        <div class="sidebar">
            <!-- åŸºæœ¬æ§åˆ¶ -->
            <div class="control-panel">
                <h3>ğŸŒ é˜´å½±æ¨¡æ‹Ÿå™¨</h3>
                
                <div class="time-display" id="currentTime">
                    2025å¹´1æœˆ7æ—¥ 12:00
                </div>

                <div class="control-group">
                    <label>ğŸ“… æ—¥æœŸ</label>
                    <input type="date" id="dateInput" />
                </div>

                <div class="control-group">
                    <label>ğŸ• æ—¶é—´</label>
                    <input type="time" id="timeInput" />
                </div>

                <div class="button-group">
                    <button onclick="setCurrentTime()">å½“å‰æ—¶é—´</button>
                    <button onclick="animateTime()">æ—¶é—´åŠ¨ç”»</button>
                </div>

                <div class="sun-info" id="sunInfo">
                    <strong>å¤ªé˜³ä¿¡æ¯</strong><br>
                    é«˜åº¦è§’: --Â°<br>
                    æ–¹ä½è§’: --Â°
                </div>
            </div>

            <!-- å›¾å±‚æ§åˆ¶ -->
            <div class="control-panel">
                <h3>ğŸ—ºï¸ å›¾å±‚æ§åˆ¶</h3>
                
                <div class="layer-controls">
                    <input type="checkbox" id="shadowLayer" checked>
                    <label for="shadowLayer">é˜´å½±å›¾å±‚</label>
                </div>

                <div class="layer-controls">
                    <input type="checkbox" id="buildingLayer" checked>
                    <label for="buildingLayer">å»ºç­‘ç‰©å›¾å±‚</label>
                </div>

                <div class="layer-controls">
                    <input type="checkbox" id="demLayer">
                    <label for="demLayer">åœ°å½¢å›¾å±‚</label>
                </div>

                <div class="control-group">
                    <label>ğŸ¨ é˜´å½±é¢œè‰²</label>
                    <input type="color" id="shadowColor" value="#01112f">
                </div>

                <div class="control-group">
                    <label>ğŸ‘» é˜´å½±é€æ˜åº¦: <span id="opacityValue">0.7</span></label>
                    <input type="range" id="shadowOpacity" min="0" max="1" step="0.1" value="0.7">
                </div>
            </div>

            <!-- ä½ç½®ä¿¡æ¯ -->
            <div class="control-panel">
                <h3>ğŸ“ ä½ç½®ä¿¡æ¯</h3>
                
                <div class="button-group">
                    <button onclick="goToBeijing()">åŒ—äº¬</button>
                    <button onclick="goToShanghai()">ä¸Šæµ·</button>
                    <button onclick="goToGuangzhou()">å¹¿å·</button>
                </div>

                <div class="coordinates" id="coordinates">
                    çº¬åº¦: 39.9042Â°<br>
                    ç»åº¦: 116.4074Â°<br>
                    ç¼©æ”¾: 15
                </div>
            </div>

            <!-- é˜´å½±åˆ†æå·¥å…· -->
            <div class="control-panel">
                <h3>ğŸ” é˜´å½±åˆ†æå·¥å…·</h3>
                
                <div class="button-group">
                    <button onclick="enableAreaAnalysis()">åŒºåŸŸåˆ†æ</button>
                    <button onclick="clearAllAnalysis()">æ¸…é™¤åˆ†æ</button>
                </div>
                
                <div class="button-group">
                    <button onclick="generateShadowReport()">ç”ŸæˆæŠ¥å‘Š</button>
                    <button onclick="exportShadowData()">å¯¼å‡ºæ•°æ®</button>
                </div>
                
                <div class="control-group">
                    <label>ğŸ¯ åˆ†æåŠå¾„ (ç±³)</label>
                    <input type="range" id="analysisRadius" min="100" max="2000" step="100" value="500">
                    <span id="radiusValue" class="radius-display">500m</span>
                </div>
                
                <div class="status info" style="font-size: 11px; margin-top: 10px;">
                    ğŸ’¡ <strong>ä½¿ç”¨è¯´æ˜:</strong><br>
                    â€¢ ç‚¹å‡»åœ°å›¾ä»»æ„ä½ç½®è¿›è¡Œé˜´å½±åˆ†æ<br>
                    â€¢ ä½¿ç”¨"åŒºåŸŸåˆ†æ"è¿›è¡Œå¤§èŒƒå›´åˆ†æ<br>
                    â€¢ APIåŠŸèƒ½å·²å¯ç”¨ï¼Œæ”¯æŒé«˜ç²¾åº¦è®¡ç®—
                </div>
            </div>

            <!-- çŠ¶æ€ä¿¡æ¯ -->
            <div class="control-panel">
                <h3>ğŸ“Š çŠ¶æ€ä¿¡æ¯</h3>
                <div id="statusMessages">
                    <div class="status info">ğŸ”‘ APIå¯†é’¥å·²é…ç½®</div>
                    <div class="status info">ç³»ç»Ÿå‡†å¤‡å°±ç»ª</div>
                </div>
            </div>

            <!-- ä¿¡æ¯é¢æ¿ -->
            <div class="info-panel">
                <strong>ğŸ’¡ ä½¿ç”¨è¯´æ˜</strong><br>
                â€¢ è°ƒæ•´æ—¥æœŸå’Œæ—¶é—´æŸ¥çœ‹ä¸åŒçš„é˜´å½±æ•ˆæœ<br>
                â€¢ ç‚¹å‡»åœ°å›¾è·å–ç²¾ç¡®çš„é˜´å½±åˆ†ææ•°æ®<br>
                â€¢ ä½¿ç”¨åŒºåŸŸåˆ†æå·¥å…·è¿›è¡Œå¤§èŒƒå›´è¯„ä¼°<br>
                â€¢ æ”¯æŒåŒ—äº¬ã€ä¸Šæµ·ã€å¹¿å·ç­‰ä¸»è¦åŸå¸‚<br><br>
                
                <strong>ğŸ”§ æŠ€æœ¯æ ˆ</strong><br>
                â€¢ DEMæ•°æ®: è‡ªå»ºåœ°å½¢æœåŠ¡<br>
                â€¢ å»ºç­‘ç‰©: OpenStreetMap + Overpass API<br>
                â€¢ é˜´å½±è®¡ç®—: leaflet-shadow-simulator + API<br>
                â€¢ åæ ‡ç³»: WGS84 (EPSG:4326)<br><br>
                
                <strong>âœ¨ æ–°åŠŸèƒ½</strong><br>
                â€¢ â˜€ï¸ ç²¾ç¡®æ—¥ç…§æ—¶é•¿è®¡ç®—<br>
                â€¢ ğŸ” ç‚¹å‡»ä½ç½®é˜´å½±åˆ†æ<br>
                â€¢ ğŸ“Š åŒºåŸŸé˜´å½±ç»Ÿè®¡æŠ¥å‘Š<br>
                â€¢ ğŸ“ˆ é˜´å½±è¦†ç›–ç™¾åˆ†æ¯”<br>
                â€¢ ğŸ“± å¯¼å‡ºåˆ†ææ•°æ®
            </div>
        </div>

        <!-- åœ°å›¾å®¹å™¨ -->
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <!-- JavaScriptåº“ -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
    <script src="https://unpkg.com/leaflet-shadow-simulator/dist/leaflet-shadow-simulator.umd.min.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let map;
        let shadeMap;
        let buildingLayers = L.layerGroup();
        let demTileLayer;
        let animationInterval;
        let currentDate = new Date();

        // åˆå§‹åŒ–åœ°å›¾
        function initMap() {
            map = L.map('map').setView([39.9042, 116.4074], 15);
            
            // æ·»åŠ åŸºç¡€åœ°å›¾
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);

            // æ·»åŠ å»ºç­‘ç‰©å›¾å±‚ç»„
            buildingLayers.addTo(map);

            // åˆå§‹åŒ–é˜´å½±æ¨¡æ‹Ÿå™¨
            initShadowSimulator();

            // ç»‘å®šåœ°å›¾äº‹ä»¶
            map.on('move', updateCoordinates);
            map.on('zoom', updateCoordinates);
            map.on('click', onMapClick);

            // åˆå§‹åŒ–æ§ä»¶
            initControls();
            updateCoordinates();
            loadCurrentViewBuildings();
        }

        // åˆå§‹åŒ–é˜´å½±æ¨¡æ‹Ÿå™¨
        function initShadowSimulator() {
            try {
                shadeMap = L.shadeMap({
                    date: currentDate,
                    color: '#01112f',
                    opacity: 0.7,
                    apiKey: 'eyJhbGciOiJIUzI1NiJ9.eyJlbWFpbCI6Imp3dTkyM0Bjb25uZWN0LmhrdXN0LWd6LmVkdS5jbiIsImNyZWF0ZWQiOjE3NTcyNDMxNzAxMzIsImlhdCI6MTc1NzI0MzE3MH0.Z7ejYmxcuKL3Le1Ydil1uRbP_EOS_wtLA6rsSewDUoA',
                    terrainSource: {
                        tileSize: 256,
                        maxZoom: 15,
                        getSourceUrl: ({ x, y, z }) => {
                            // ä½¿ç”¨æˆ‘ä»¬è‡ªå»ºçš„DEMæœåŠ¡
                            return `http://localhost:3002/api/dem/${z}/${x}/${y}.png`;
                        },
                        getElevation: ({ r, g, b, a }) => {
                            // AWS Terrariumæ ¼å¼çš„é«˜ç¨‹è§£æ
                            return (r * 256 + g + b / 256) - 32768;
                        }
                    },
                    getFeatures: async () => {
                        // è·å–å½“å‰è§†å›¾çš„å»ºç­‘ç‰©æ•°æ®
                        return await getCurrentViewBuildings();
                    }
                }).addTo(map);

                addStatus('é˜´å½±æ¨¡æ‹Ÿå™¨åˆå§‹åŒ–æˆåŠŸ', 'info');
            } catch (error) {
                console.error('é˜´å½±æ¨¡æ‹Ÿå™¨åˆå§‹åŒ–å¤±è´¥:', error);
                addStatus('é˜´å½±æ¨¡æ‹Ÿå™¨åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
            }
        }

        // è·å–å½“å‰è§†å›¾çš„å»ºç­‘ç‰©æ•°æ®
        async function getCurrentViewBuildings() {
            if (map.getZoom() < 14) {
                return []; // ä½ç¼©æ”¾çº§åˆ«ä¸æ˜¾ç¤ºå»ºç­‘ç‰©
            }

            try {
                const bounds = map.getBounds();
                const tiles = getTilesInBounds(bounds, Math.min(map.getZoom(), 17));
                const buildings = [];

                for (const tile of tiles) {
                    try {
                        const response = await fetch(`http://localhost:3002/api/buildings/${tile.z}/${tile.x}/${tile.y}.json`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.features) {
                                // è½¬æ¢ä¸ºshadow-simulatoréœ€è¦çš„æ ¼å¼
                                data.features.forEach(feature => {
                                    if (feature.properties) {
                                        // ç¡®ä¿æœ‰é«˜åº¦å±æ€§
                                        if (!feature.properties.height) {
                                            feature.properties.height = feature.properties.levels ? 
                                                feature.properties.levels * 3 : 10; // é»˜è®¤10ç±³
                                        }
                                        // æ·»åŠ render_heightå±æ€§ï¼ˆshadow-simulatoréœ€è¦ï¼‰
                                        feature.properties.render_height = feature.properties.height;
                                    }
                                });
                                buildings.push(...data.features);
                            }
                        }
                    } catch (error) {
                        console.warn(`è·å–å»ºç­‘ç‰©ç“¦ç‰‡ ${tile.z}/${tile.x}/${tile.y} å¤±è´¥:`, error);
                    }
                }

                console.log(`è·å–äº† ${buildings.length} ä¸ªå»ºç­‘ç‰©ç”¨äºé˜´å½±è®¡ç®—`);
                return buildings;
            } catch (error) {
                console.error('è·å–å»ºç­‘ç‰©æ•°æ®å¤±è´¥:', error);
                return [];
            }
        }

        // è®¡ç®—è¾¹ç•Œæ¡†å†…çš„ç“¦ç‰‡
        function getTilesInBounds(bounds, zoom) {
            const tiles = [];
            const nw = bounds.getNorthWest();
            const se = bounds.getSouthEast();
            
            const minTile = latLngToTile(nw.lat, nw.lng, zoom);
            const maxTile = latLngToTile(se.lat, se.lng, zoom);
            
            for (let x = minTile.x; x <= maxTile.x; x++) {
                for (let y = minTile.y; y <= maxTile.y; y++) {
                    tiles.push({ z: zoom, x: x, y: y });
                }
            }
            
            return tiles.slice(0, 20); // é™åˆ¶æœ€å¤§ç“¦ç‰‡æ•°é‡
        }

        // ç»çº¬åº¦è½¬ç“¦ç‰‡åæ ‡
        function latLngToTile(lat, lng, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(lat * Math.PI / 180)) / Math.PI) / 2 * n);
            return { x, y };
        }

        // åŠ è½½å½“å‰è§†å›¾çš„å»ºç­‘ç‰©
        async function loadCurrentViewBuildings() {
            if (!document.getElementById('buildingLayer').checked) {
                return;
            }

            try {
                buildingLayers.clearLayers();
                const buildings = await getCurrentViewBuildings();
                
                if (buildings.length > 0) {
                    const geoJsonLayer = L.geoJSON(buildings, {
                        style: function(feature) {
                            const height = feature.properties.height || 10;
                            const isHighRise = height > 20;
                            
                            return {
                                color: isHighRise ? '#0064ff' : '#ff6b6b',
                                weight: 1,
                                fillOpacity: 0.3,
                                fillColor: isHighRise ? '#0064ff' : '#ff6b6b'
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties) {
                                const props = feature.properties;
                                layer.bindPopup(`
                                    <div style="min-width: 200px;">
                                        <h4>ğŸ¢ å»ºç­‘ç‰©ä¿¡æ¯</h4>
                                        <p><strong>ç±»å‹:</strong> ${props.buildingType || 'æœªçŸ¥'}</p>
                                        <p><strong>é«˜åº¦:</strong> ${props.height || 'æœªçŸ¥'}m</p>
                                        <p><strong>æ¥¼å±‚:</strong> ${props.levels || 'æœªçŸ¥'}</p>
                                    </div>
                                `);
                            }
                        }
                    });
                    
                    buildingLayers.addLayer(geoJsonLayer);
                    addStatus(`åŠ è½½äº† ${buildings.length} ä¸ªå»ºç­‘ç‰©`, 'info');
                }
            } catch (error) {
                console.error('åŠ è½½å»ºç­‘ç‰©å¤±è´¥:', error);
                addStatus('åŠ è½½å»ºç­‘ç‰©å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åˆå§‹åŒ–æ§ä»¶
        function initControls() {
            // è®¾ç½®å½“å‰æ—¥æœŸå’Œæ—¶é—´
            const now = new Date();
            document.getElementById('dateInput').value = now.toISOString().split('T')[0];
            document.getElementById('timeInput').value = now.toTimeString().slice(0, 5);
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('dateInput').addEventListener('change', updateDateTime);
            document.getElementById('timeInput').addEventListener('change', updateDateTime);
            document.getElementById('shadowColor').addEventListener('change', updateShadowColor);
            document.getElementById('shadowOpacity').addEventListener('input', updateShadowOpacity);
            document.getElementById('shadowLayer').addEventListener('change', toggleShadowLayer);
            document.getElementById('buildingLayer').addEventListener('change', toggleBuildingLayer);
            document.getElementById('demLayer').addEventListener('change', toggleDEMLayer);
            document.getElementById('analysisRadius').addEventListener('input', updateAnalysisRadius);
            
            updateTimeDisplay();
            updateSunInfo();
        }
        
        // æ›´æ–°åˆ†æåŠå¾„æ˜¾ç¤º
        function updateAnalysisRadius() {
            const radius = document.getElementById('analysisRadius').value;
            document.getElementById('radiusValue').textContent = radius + 'm';
        }

        // æ›´æ–°æ—¥æœŸæ—¶é—´
        function updateDateTime() {
            const dateStr = document.getElementById('dateInput').value;
            const timeStr = document.getElementById('timeInput').value;
            
            if (dateStr && timeStr) {
                currentDate = new Date(`${dateStr}T${timeStr}`);
                if (shadeMap) {
                    shadeMap.setDate(currentDate);
                }
                updateTimeDisplay();
                updateSunInfo();
            }
        }

        // è®¾ç½®å½“å‰æ—¶é—´
        function setCurrentTime() {
            const now = new Date();
            document.getElementById('dateInput').value = now.toISOString().split('T')[0];
            document.getElementById('timeInput').value = now.toTimeString().slice(0, 5);
            updateDateTime();
        }

        // æ—¶é—´åŠ¨ç”»
        function animateTime() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
                addStatus('æ—¶é—´åŠ¨ç”»å·²åœæ­¢', 'info');
                return;
            }
            
            animationInterval = setInterval(() => {
                currentDate.setMinutes(currentDate.getMinutes() + 30);
                
                if (shadeMap) {
                    shadeMap.setDate(currentDate);
                }
                
                updateTimeDisplay();
                updateSunInfo();
            }, 500);
            
            addStatus('æ—¶é—´åŠ¨ç”»å·²å¯åŠ¨', 'info');
        }

        // æ›´æ–°æ—¶é—´æ˜¾ç¤º
        function updateTimeDisplay() {
            document.getElementById('currentTime').textContent = 
                currentDate.toLocaleDateString('zh-CN', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                }) + ' ' + 
                currentDate.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
        }

        // æ›´æ–°å¤ªé˜³ä¿¡æ¯
        function updateSunInfo() {
            if (!map) return;
            
            const center = map.getCenter();
            const sunPosition = SunCalc.getPosition(currentDate, center.lat, center.lng);
            
            const altitude = (sunPosition.altitude * 180 / Math.PI).toFixed(1);
            const azimuth = ((sunPosition.azimuth * 180 / Math.PI) + 180).toFixed(1);
            
            document.getElementById('sunInfo').innerHTML = `
                <strong>å¤ªé˜³ä¿¡æ¯</strong><br>
                é«˜åº¦è§’: ${altitude}Â°<br>
                æ–¹ä½è§’: ${azimuth}Â°
            `;
        }

        // æ›´æ–°é˜´å½±é¢œè‰²
        function updateShadowColor() {
            const color = document.getElementById('shadowColor').value;
            if (shadeMap) {
                shadeMap.setColor(color);
            }
        }

        // æ›´æ–°é˜´å½±é€æ˜åº¦
        function updateShadowOpacity() {
            const opacity = document.getElementById('shadowOpacity').value;
            document.getElementById('opacityValue').textContent = opacity;
            if (shadeMap) {
                shadeMap.setOpacity(parseFloat(opacity));
            }
        }

        // åˆ‡æ¢é˜´å½±å›¾å±‚
        function toggleShadowLayer() {
            const enabled = document.getElementById('shadowLayer').checked;
            if (shadeMap) {
                if (enabled) {
                    map.addLayer(shadeMap);
                } else {
                    map.removeLayer(shadeMap);
                }
            }
        }

        // åˆ‡æ¢å»ºç­‘ç‰©å›¾å±‚
        function toggleBuildingLayer() {
            const enabled = document.getElementById('buildingLayer').checked;
            if (enabled) {
                map.addLayer(buildingLayers);
                loadCurrentViewBuildings();
            } else {
                map.removeLayer(buildingLayers);
            }
        }

        // åˆ‡æ¢DEMå›¾å±‚
        function toggleDEMLayer() {
            const enabled = document.getElementById('demLayer').checked;
            
            if (enabled && !demTileLayer) {
                demTileLayer = L.tileLayer('http://localhost:3002/api/dem/{z}/{x}/{y}.png', {
                    attribution: 'Â© è‡ªå»ºDEMæœåŠ¡',
                    maxZoom: 15,
                    opacity: 0.5
                });
            }
            
            if (enabled) {
                demTileLayer.addTo(map);
                addStatus('åœ°å½¢å›¾å±‚å·²å¼€å¯', 'info');
            } else if (demTileLayer) {
                map.removeLayer(demTileLayer);
                addStatus('åœ°å½¢å›¾å±‚å·²å…³é—­', 'info');
            }
        }

        // è·³è½¬åˆ°åŒ—äº¬
        function goToBeijing() {
            map.setView([39.9042, 116.4074], 15);
            setTimeout(loadCurrentViewBuildings, 1000);
        }

        // è·³è½¬åˆ°ä¸Šæµ·
        function goToShanghai() {
            map.setView([31.2304, 121.4737], 15);
            setTimeout(loadCurrentViewBuildings, 1000);
        }

        // è·³è½¬åˆ°å¹¿å·
        function goToGuangzhou() {
            map.setView([23.1291, 113.2644], 15);
            setTimeout(loadCurrentViewBuildings, 1000);
        }

        // æ›´æ–°åæ ‡æ˜¾ç¤º
        function updateCoordinates() {
            const center = map.getCenter();
            const zoom = map.getZoom();
            
            document.getElementById('coordinates').innerHTML = `
                çº¬åº¦: ${center.lat.toFixed(4)}Â°<br>
                ç»åº¦: ${center.lng.toFixed(4)}Â°<br>
                ç¼©æ”¾: ${zoom}
            `;
            
            updateSunInfo();
        }

        // åœ°å›¾ç‚¹å‡»äº‹ä»¶
        function onMapClick(e) {
            const { lat, lng } = e.latlng;
            console.log(`ç‚¹å‡»ä½ç½®: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
            
            // è·å–ç‚¹å‡»ä½ç½®çš„é˜´å½±åˆ†æ
            if (shadeMap) {
                try {
                    // è·å–æ—¥ç…§æ—¶é•¿
                    const hoursOfSun = shadeMap.getHoursOfSun(e.containerPoint.x, e.containerPoint.y);
                    if (hoursOfSun !== undefined) {
                        addStatus(`è¯¥ä½ç½®æ—¥ç…§æ—¶é•¿: ${hoursOfSun.toFixed(1)}å°æ—¶`, 'info');
                        
                        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯å¼¹çª—
                        const popup = L.popup()
                            .setLatLng(e.latlng)
                            .setContent(`
                                <div style="min-width: 200px;">
                                    <h4>ğŸ“Š é˜´å½±åˆ†æ</h4>
                                    <p><strong>ğŸ“ ä½ç½®:</strong> ${lat.toFixed(4)}Â°, ${lng.toFixed(4)}Â°</p>
                                    <p><strong>â˜€ï¸ æ—¥ç…§æ—¶é•¿:</strong> ${hoursOfSun.toFixed(1)} å°æ—¶</p>
                                    <p><strong>ğŸŒ‘ é˜´å½±è¦†ç›–:</strong> ${((24 - hoursOfSun) / 24 * 100).toFixed(1)}%</p>
                                    <p><strong>ğŸ“… æ—¥æœŸ:</strong> ${currentDate.toLocaleDateString()}</p>
                                    <button onclick="analyzeShadowArea(${lat}, ${lng})" style="margin-top: 10px; padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        ğŸ” è¯¦ç»†åˆ†æ
                                    </button>
                                </div>
                            `)
                            .openOn(map);
                    }
                    
                    // è·å–é˜´å½±çŠ¶æ€
                    if (shadeMap.getShadeAtPoint) {
                        const shadeLevel = shadeMap.getShadeAtPoint(e.containerPoint.x, e.containerPoint.y);
                        if (shadeLevel !== undefined) {
                            addStatus(`é˜´å½±å¼ºåº¦: ${(shadeLevel * 100).toFixed(1)}%`, 'info');
                        }
                    }
                    
                } catch (error) {
                    console.warn('é˜´å½±åˆ†æå¤±è´¥:', error);
                    addStatus('ç‚¹å‡»é˜´å½±åˆ†æå¤±è´¥: ' + error.message, 'warning');
                }
            }
        }

        // åŒºåŸŸé˜´å½±åˆ†æ
        function analyzeShadowArea(lat, lng) {
            if (!shadeMap) {
                addStatus('é˜´å½±æ¨¡æ‹Ÿå™¨æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            try {
                // åˆ›å»ºåˆ†æåŒºåŸŸ (500ç±³åŠå¾„)
                const radius = 500; // ç±³
                const circle = L.circle([lat, lng], {
                    radius: radius,
                    color: '#e74c3c',
                    fillColor: '#e74c3c',
                    fillOpacity: 0.2,
                    weight: 2
                }).addTo(map);
                
                // åˆ†æåŒºåŸŸå†…çš„é˜´å½±æƒ…å†µ
                const bounds = circle.getBounds();
                const center = bounds.getCenter();
                
                // è·å–å¤šä¸ªé‡‡æ ·ç‚¹çš„é˜´å½±æ•°æ®
                const samplePoints = [];
                const gridSize = 5; // 5x5ç½‘æ ¼
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const latOffset = (bounds.getNorth() - bounds.getSouth()) * (i / (gridSize - 1));
                        const lngOffset = (bounds.getEast() - bounds.getWest()) * (j / (gridSize - 1));
                        
                        const sampleLat = bounds.getSouth() + latOffset;
                        const sampleLng = bounds.getWest() + lngOffset;
                        
                        const point = map.latLngToContainerPoint([sampleLat, sampleLng]);
                        
                        if (shadeMap.getHoursOfSun) {
                            const hoursOfSun = shadeMap.getHoursOfSun(point.x, point.y);
                            if (hoursOfSun !== undefined) {
                                samplePoints.push({
                                    lat: sampleLat,
                                    lng: sampleLng,
                                    hoursOfSun: hoursOfSun,
                                    shadowPercent: ((24 - hoursOfSun) / 24 * 100)
                                });
                            }
                        }
                    }
                }
                
                if (samplePoints.length > 0) {
                    // è®¡ç®—ç»Ÿè®¡æ•°æ®
                    const avgHoursOfSun = samplePoints.reduce((sum, p) => sum + p.hoursOfSun, 0) / samplePoints.length;
                    const avgShadowPercent = samplePoints.reduce((sum, p) => sum + p.shadowPercent, 0) / samplePoints.length;
                    const maxShadowPercent = Math.max(...samplePoints.map(p => p.shadowPercent));
                    const minShadowPercent = Math.min(...samplePoints.map(p => p.shadowPercent));
                    
                    // æ˜¾ç¤ºåˆ†æç»“æœ
                    const popup = L.popup()
                        .setLatLng([lat, lng])
                        .setContent(`
                            <div style="min-width: 280px;">
                                <h4>ğŸ” åŒºåŸŸé˜´å½±åˆ†ææŠ¥å‘Š</h4>
                                <p><strong>ğŸ“ åˆ†æä¸­å¿ƒ:</strong> ${lat.toFixed(4)}Â°, ${lng.toFixed(4)}Â°</p>
                                <p><strong>ğŸ“ åˆ†æåŠå¾„:</strong> ${radius}ç±³</p>
                                <p><strong>ğŸ“Š é‡‡æ ·ç‚¹æ•°:</strong> ${samplePoints.length}ä¸ª</p>
                                <hr style="margin: 10px 0;">
                                <p><strong>â˜€ï¸ å¹³å‡æ—¥ç…§:</strong> ${avgHoursOfSun.toFixed(1)} å°æ—¶</p>
                                <p><strong>ğŸŒ‘ å¹³å‡é˜´å½±:</strong> ${avgShadowPercent.toFixed(1)}%</p>
                                <p><strong>ğŸ“ˆ é˜´å½±èŒƒå›´:</strong> ${minShadowPercent.toFixed(1)}% - ${maxShadowPercent.toFixed(1)}%</p>
                                <hr style="margin: 10px 0;">
                                <p><strong>ğŸ“… åˆ†ææ—¥æœŸ:</strong> ${currentDate.toLocaleDateString()}</p>
                                <p><strong>ğŸ• åˆ†ææ—¶é—´:</strong> ${currentDate.toLocaleTimeString().slice(0, 5)}</p>
                                <button onclick="clearAnalysisArea()" style="margin-top: 10px; padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                    âŒ æ¸…é™¤åˆ†æ
                                </button>
                            </div>
                        `)
                        .openOn(map);
                        
                    // ä¿å­˜åˆ†æåœ†åœˆå¼•ç”¨
                    window.currentAnalysisCircle = circle;
                    
                    addStatus(`åŒºåŸŸé˜´å½±åˆ†æå®Œæˆ: å¹³å‡é˜´å½±è¦†ç›– ${avgShadowPercent.toFixed(1)}%`, 'info');
                } else {
                    addStatus('æ— æ³•è·å–è¯¥åŒºåŸŸçš„é˜´å½±æ•°æ®', 'warning');
                    map.removeLayer(circle);
                }
                
            } catch (error) {
                console.error('åŒºåŸŸé˜´å½±åˆ†æå¤±è´¥:', error);
                addStatus('åŒºåŸŸé˜´å½±åˆ†æå¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // å¯ç”¨åŒºåŸŸåˆ†ææ¨¡å¼
        function enableAreaAnalysis() {
            addStatus('è¯·åœ¨åœ°å›¾ä¸Šç‚¹å‡»è¦åˆ†æçš„åŒºåŸŸä¸­å¿ƒç‚¹', 'info');
            
            // æ”¹å˜é¼ æ ‡æ ·å¼
            map.getContainer().style.cursor = 'crosshair';
            
            // ä¸´æ—¶æ”¹å˜ç‚¹å‡»äº‹ä»¶
            map.off('click', onMapClick);
            map.once('click', function(e) {
                map.getContainer().style.cursor = '';
                const radius = document.getElementById('analysisRadius').value;
                analyzeShadowAreaWithRadius(e.latlng.lat, e.latlng.lng, parseInt(radius));
                map.on('click', onMapClick);
            });
        }

        // å¸¦è‡ªå®šä¹‰åŠå¾„çš„åŒºåŸŸåˆ†æ
        function analyzeShadowAreaWithRadius(lat, lng, radius) {
            if (!shadeMap) {
                addStatus('é˜´å½±æ¨¡æ‹Ÿå™¨æœªåˆå§‹åŒ–', 'error');
                return;
            }
            
            try {
                // æ¸…é™¤ä¹‹å‰çš„åˆ†æ
                if (window.currentAnalysisCircle) {
                    map.removeLayer(window.currentAnalysisCircle);
                }
                
                // åˆ›å»ºåˆ†æåŒºåŸŸ
                const circle = L.circle([lat, lng], {
                    radius: radius,
                    color: '#3498db',
                    fillColor: '#3498db',
                    fillOpacity: 0.2,
                    weight: 2
                }).addTo(map);
                
                // æ·»åŠ ä¸­å¿ƒç‚¹æ ‡è®°
                const centerMarker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'analysis-center',
                        html: 'ğŸ¯',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(map);
                
                // åˆ†æåŒºåŸŸå†…çš„é˜´å½±æƒ…å†µ
                const bounds = circle.getBounds();
                const samplePoints = [];
                const gridSize = Math.min(10, Math.max(5, Math.floor(radius / 100))); // æ ¹æ®åŠå¾„è°ƒæ•´ç½‘æ ¼å¯†åº¦
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const latOffset = (bounds.getNorth() - bounds.getSouth()) * (i / (gridSize - 1));
                        const lngOffset = (bounds.getEast() - bounds.getWest()) * (j / (gridSize - 1));
                        
                        const sampleLat = bounds.getSouth() + latOffset;
                        const sampleLng = bounds.getWest() + lngOffset;
                        
                        const point = map.latLngToContainerPoint([sampleLat, sampleLng]);
                        
                        if (shadeMap.getHoursOfSun) {
                            const hoursOfSun = shadeMap.getHoursOfSun(point.x, point.y);
                            if (hoursOfSun !== undefined) {
                                samplePoints.push({
                                    lat: sampleLat,
                                    lng: sampleLng,
                                    hoursOfSun: hoursOfSun,
                                    shadowPercent: ((24 - hoursOfSun) / 24 * 100)
                                });
                            }
                        }
                    }
                }
                
                if (samplePoints.length > 0) {
                    // è®¡ç®—è¯¦ç»†ç»Ÿè®¡æ•°æ®
                    const avgHoursOfSun = samplePoints.reduce((sum, p) => sum + p.hoursOfSun, 0) / samplePoints.length;
                    const avgShadowPercent = samplePoints.reduce((sum, p) => sum + p.shadowPercent, 0) / samplePoints.length;
                    const maxShadowPercent = Math.max(...samplePoints.map(p => p.shadowPercent));
                    const minShadowPercent = Math.min(...samplePoints.map(p => p.shadowPercent));
                    const stdDev = Math.sqrt(samplePoints.reduce((sum, p) => sum + Math.pow(p.shadowPercent - avgShadowPercent, 2), 0) / samplePoints.length);
                    
                    // é˜´å½±ç­‰çº§åˆ†å¸ƒ
                    const shadowLevels = {
                        æ— é˜´å½±: samplePoints.filter(p => p.shadowPercent < 10).length,
                        è½»å¾®é˜´å½±: samplePoints.filter(p => p.shadowPercent >= 10 && p.shadowPercent < 25).length,
                        ä¸­ç­‰é˜´å½±: samplePoints.filter(p => p.shadowPercent >= 25 && p.shadowPercent < 50).length,
                        é‡åº¦é˜´å½±: samplePoints.filter(p => p.shadowPercent >= 50 && p.shadowPercent < 75).length,
                        æé‡é˜´å½±: samplePoints.filter(p => p.shadowPercent >= 75).length
                    };
                    
                    // æ˜¾ç¤ºè¯¦ç»†åˆ†æç»“æœ
                    const popup = L.popup()
                        .setLatLng([lat, lng])
                        .setContent(`
                            <div style="min-width: 320px; max-height: 400px; overflow-y: auto;">
                                <h4>ğŸ“Š é«˜çº§åŒºåŸŸé˜´å½±åˆ†æ</h4>
                                <p><strong>ğŸ“ åˆ†æä¸­å¿ƒ:</strong> ${lat.toFixed(4)}Â°, ${lng.toFixed(4)}Â°</p>
                                <p><strong>ğŸ“ åˆ†æåŠå¾„:</strong> ${radius}ç±³ (${(Math.PI * radius * radius / 10000).toFixed(2)}å…¬é¡·)</p>
                                <p><strong>ğŸ“Š é‡‡æ ·ç‚¹æ•°:</strong> ${samplePoints.length}ä¸ª (${gridSize}Ã—${gridSize}ç½‘æ ¼)</p>
                                
                                <hr style="margin: 10px 0;">
                                <h5>â˜€ï¸ æ—¥ç…§ç»Ÿè®¡</h5>
                                <p><strong>å¹³å‡æ—¥ç…§:</strong> ${avgHoursOfSun.toFixed(1)} å°æ—¶/å¤©</p>
                                <p><strong>å¹³å‡é˜´å½±:</strong> ${avgShadowPercent.toFixed(1)}%</p>
                                <p><strong>é˜´å½±èŒƒå›´:</strong> ${minShadowPercent.toFixed(1)}% - ${maxShadowPercent.toFixed(1)}%</p>
                                <p><strong>æ ‡å‡†å·®:</strong> ${stdDev.toFixed(1)}%</p>
                                
                                <hr style="margin: 10px 0;">
                                <h5>ğŸŒ‘ é˜´å½±åˆ†å¸ƒ</h5>
                                <div style="font-size: 11px;">
                                    <p>â˜€ï¸ æ— é˜´å½± (<10%): ${shadowLevels.æ— é˜´å½±}ç‚¹ (${(shadowLevels.æ— é˜´å½±/samplePoints.length*100).toFixed(1)}%)</p>
                                    <p>ğŸŒ¤ï¸ è½»å¾®é˜´å½± (10-25%): ${shadowLevels.è½»å¾®é˜´å½±}ç‚¹ (${(shadowLevels.è½»å¾®é˜´å½±/samplePoints.length*100).toFixed(1)}%)</p>
                                    <p>â›… ä¸­ç­‰é˜´å½± (25-50%): ${shadowLevels.ä¸­ç­‰é˜´å½±}ç‚¹ (${(shadowLevels.ä¸­ç­‰é˜´å½±/samplePoints.length*100).toFixed(1)}%)</p>
                                    <p>â˜ï¸ é‡åº¦é˜´å½± (50-75%): ${shadowLevels.é‡åº¦é˜´å½±}ç‚¹ (${(shadowLevels.é‡åº¦é˜´å½±/samplePoints.length*100).toFixed(1)}%)</p>
                                    <p>ğŸŒ‘ æé‡é˜´å½± (>75%): ${shadowLevels.æé‡é˜´å½±}ç‚¹ (${(shadowLevels.æé‡é˜´å½±/samplePoints.length*100).toFixed(1)}%)</p>
                                </div>
                                
                                <hr style="margin: 10px 0;">
                                <p><strong>ğŸ“… åˆ†ææ—¶é—´:</strong> ${currentDate.toLocaleString()}</p>
                                
                                <div style="margin-top: 10px;">
                                    <button onclick="clearAllAnalysis()" style="padding: 5px 10px; background: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer; margin-right: 5px;">
                                        âŒ æ¸…é™¤
                                    </button>
                                    <button onclick="saveAnalysisData()" style="padding: 5px 10px; background: #27ae60; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        ğŸ’¾ ä¿å­˜
                                    </button>
                                </div>
                            </div>
                        `)
                        .openOn(map);
                        
                    // ä¿å­˜åˆ†ææ•°æ®
                    window.currentAnalysisData = {
                        circle: circle,
                        marker: centerMarker,
                        data: samplePoints,
                        stats: {
                            avgHoursOfSun,
                            avgShadowPercent,
                            maxShadowPercent,
                            minShadowPercent,
                            stdDev,
                            shadowLevels
                        },
                        metadata: {
                            center: [lat, lng],
                            radius: radius,
                            date: new Date(currentDate),
                            sampleCount: samplePoints.length
                        }
                    };
                    
                    addStatus(`åŒºåŸŸé˜´å½±åˆ†æå®Œæˆ: ${radius}ç±³åŠå¾„ï¼Œå¹³å‡é˜´å½± ${avgShadowPercent.toFixed(1)}%`, 'info');
                } else {
                    addStatus('æ— æ³•è·å–è¯¥åŒºåŸŸçš„é˜´å½±æ•°æ®', 'warning');
                    map.removeLayer(circle);
                    map.removeLayer(centerMarker);
                }
                
            } catch (error) {
                console.error('åŒºåŸŸé˜´å½±åˆ†æå¤±è´¥:', error);
                addStatus('åŒºåŸŸé˜´å½±åˆ†æå¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ¸…é™¤æ‰€æœ‰åˆ†æ
        function clearAllAnalysis() {
            if (window.currentAnalysisData) {
                map.removeLayer(window.currentAnalysisData.circle);
                map.removeLayer(window.currentAnalysisData.marker);
                window.currentAnalysisData = null;
            }
            if (window.currentAnalysisCircle) {
                map.removeLayer(window.currentAnalysisCircle);
                window.currentAnalysisCircle = null;
            }
            map.closePopup();
            addStatus('å·²æ¸…é™¤æ‰€æœ‰åˆ†ææ•°æ®', 'info');
        }
        
        // æ¸…é™¤åˆ†æåŒºåŸŸ (å…¼å®¹æ—§ç‰ˆæœ¬)
        function clearAnalysisArea() {
            clearAllAnalysis();
        }

        // ç”Ÿæˆé˜´å½±æŠ¥å‘Š
        function generateShadowReport() {
            if (!window.currentAnalysisData) {
                addStatus('è¯·å…ˆè¿›è¡ŒåŒºåŸŸåˆ†æ', 'warning');
                return;
            }
            
            const data = window.currentAnalysisData;
            const report = `
# é˜´å½±åˆ†ææŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯
- **åˆ†æä½ç½®**: ${data.metadata.center[0].toFixed(6)}Â°, ${data.metadata.center[1].toFixed(6)}Â°
- **åˆ†æåŠå¾„**: ${data.metadata.radius}ç±³
- **åˆ†æé¢ç§¯**: ${(Math.PI * data.metadata.radius * data.metadata.radius / 10000).toFixed(2)}å…¬é¡·
- **åˆ†ææ—¶é—´**: ${data.metadata.date.toLocaleString()}
- **é‡‡æ ·ç‚¹æ•°**: ${data.metadata.sampleCount}ä¸ª

## ç»Ÿè®¡ç»“æœ
- **å¹³å‡æ—¥ç…§æ—¶é•¿**: ${data.stats.avgHoursOfSun.toFixed(2)}å°æ—¶/å¤©
- **å¹³å‡é˜´å½±è¦†ç›–**: ${data.stats.avgShadowPercent.toFixed(2)}%
- **é˜´å½±è¦†ç›–èŒƒå›´**: ${data.stats.minShadowPercent.toFixed(2)}% - ${data.stats.maxShadowPercent.toFixed(2)}%
- **æ ‡å‡†å·®**: ${data.stats.stdDev.toFixed(2)}%

## é˜´å½±åˆ†å¸ƒ
- **æ— é˜´å½±åŒºåŸŸ** (<10%): ${(data.stats.shadowLevels.æ— é˜´å½±/data.metadata.sampleCount*100).toFixed(1)}%
- **è½»å¾®é˜´å½±åŒºåŸŸ** (10-25%): ${(data.stats.shadowLevels.è½»å¾®é˜´å½±/data.metadata.sampleCount*100).toFixed(1)}%
- **ä¸­ç­‰é˜´å½±åŒºåŸŸ** (25-50%): ${(data.stats.shadowLevels.ä¸­ç­‰é˜´å½±/data.metadata.sampleCount*100).toFixed(1)}%
- **é‡åº¦é˜´å½±åŒºåŸŸ** (50-75%): ${(data.stats.shadowLevels.é‡åº¦é˜´å½±/data.metadata.sampleCount*100).toFixed(1)}%
- **æé‡é˜´å½±åŒºåŸŸ** (>75%): ${(data.stats.shadowLevels.æé‡é˜´å½±/data.metadata.sampleCount*100).toFixed(1)}%

---
æŠ¥å‘Šç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}
            `.trim();
            
            // å¤åˆ¶åˆ°å‰ªè´´æ¿
            navigator.clipboard.writeText(report).then(() => {
                addStatus('é˜´å½±åˆ†ææŠ¥å‘Šå·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'info');
            }).catch(() => {
                // é™çº§æ–¹æ¡ˆï¼šæ˜¾ç¤ºæŠ¥å‘Š
                const reportWindow = window.open('', '_blank');
                reportWindow.document.write(`<pre style="font-family: monospace; white-space: pre-wrap; padding: 20px;">${report}</pre>`);
                addStatus('é˜´å½±åˆ†ææŠ¥å‘Šå·²åœ¨æ–°çª—å£ä¸­æ‰“å¼€', 'info');
            });
        }

        // å¯¼å‡ºé˜´å½±æ•°æ®
        function exportShadowData() {
            if (!window.currentAnalysisData) {
                addStatus('è¯·å…ˆè¿›è¡ŒåŒºåŸŸåˆ†æ', 'warning');
                return;
            }
            
            const data = window.currentAnalysisData;
            const exportData = {
                metadata: data.metadata,
                statistics: data.stats,
                samplePoints: data.data.map(point => ({
                    latitude: point.lat,
                    longitude: point.lng,
                    hoursOfSun: point.hoursOfSun,
                    shadowPercentage: point.shadowPercent
                }))
            };
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shadow-analysis-${data.metadata.date.toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addStatus('é˜´å½±åˆ†ææ•°æ®å·²å¯¼å‡º', 'info');
        }

        // ä¿å­˜åˆ†ææ•°æ®
        function saveAnalysisData() {
            if (window.currentAnalysisData) {
                localStorage.setItem('shadowAnalysisData', JSON.stringify(window.currentAnalysisData.data));
                localStorage.setItem('shadowAnalysisMetadata', JSON.stringify(window.currentAnalysisData.metadata));
                addStatus('åˆ†ææ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°', 'info');
            }
        }

        // æ·»åŠ çŠ¶æ€æ¶ˆæ¯
        function addStatus(message, type = 'info') {
            const container = document.getElementById('statusMessages');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            
            container.insertBefore(statusDiv, container.firstChild);
            
            // é™åˆ¶æ¶ˆæ¯æ•°é‡
            while (container.children.length > 5) {
                container.removeChild(container.lastChild);
            }
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('å®Œæ•´é˜´å½±æ¨¡æ‹Ÿå™¨åˆå§‹åŒ–ä¸­...');
            initMap();
            addStatus('å®Œæ•´é˜´å½±æ¨¡æ‹Ÿå™¨å·²å¯åŠ¨', 'info');
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', function() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
        });
    </script>
</body>
</html>
